在多线程系统中，**用户线程**（User Threads）和**内核线程**（Kernel Threads）是两种基本的线程类型。根据不同的线程模型，系统如何调度和管理这些线程也有所不同。你提到的 **Local Scheduling (LWP映射)** 和 **Global Scheduling** 代表了不同的调度策略和调度竞争范围。为了更清楚地理解这些概念，我们需要从 **线程模型** 和 **调度策略** 的角度进行详细解析。

### 1. **用户线程 vs 内核线程**
#### **用户线程 (User Threads)**：
- **定义**：用户线程是由用户级的线程库（如 `pthread`）管理和调度的。操作系统的内核对用户线程不进行直接管理，因此内核无法感知线程的存在。
- **管理**：用户线程的创建、调度和销毁通常由用户空间的线程库负责（如 `pthread`、Java线程等）。
- **局限性**：操作系统内核通常无法识别用户线程。当用户线程执行系统调用或阻塞时，整个进程（所有线程）可能会被阻塞。

#### **内核线程 (Kernel Threads)**：
- **定义**：内核线程是由操作系统内核直接管理和调度的线程。每个内核线程都有一个独立的内核结构（如栈、寄存器等），由操作系统调度器控制。
- **管理**：内核线程的创建、调度和销毁由操作系统内核直接控制，内核能够识别并管理它们。
- **优点**：内核线程可以在多核系统中并行执行，并且一个内核线程的阻塞不会影响其他线程。

### 2. **线程模型：多对一、多对多、一对一**
不同的线程模型决定了用户线程如何与内核线程进行映射，并影响线程的调度方式。我们可以从以下三种常见的线程模型来理解：

#### **Many-to-One 模型（多对一模型）**
- **定义**：在这种模型中，多个用户线程被映射到 **一个** 内核线程。所有的用户线程都通过一个内核线程来执行，内核并不知道有多个用户线程。
- **调度**：用户线程的调度是由用户级线程库负责，操作系统内核无法感知到这些用户线程。
- **缺点**：由于操作系统只看到一个内核线程，因此多个用户线程不能并行地在多个处理器核心上执行。而且，如果一个用户线程执行阻塞的系统调用，那么整个进程（包括其他线程）都将被阻塞。

#### **Many-to-Many 模型（多对多模型）**
- **定义**：在这种模型中，多个用户线程可以映射到 **多个** 内核线程。操作系统通过多个内核线程来调度多个用户线程。这种方式使得线程能够在多个处理器核心上并行执行。
- **调度**：用户线程库负责调度多个用户线程，而内核线程则通过内核调度器进行调度。
- **优点**：能够利用多核处理器，多个用户线程可以并行运行。且一个内核线程阻塞时，不会阻塞所有的用户线程。

#### **One-to-One 模型（一对一模型）**
- **定义**：每个用户线程都有一个对应的内核线程。这种模型下，操作系统内核直接管理所有的线程，内核线程和用户线程一一对应。
- **调度**：内核线程由操作系统内核调度，用户线程的调度由用户线程库负责。
- **优点**：用户线程可以利用多个核心的计算资源，并且每个线程都由内核调度，能够独立执行，互不阻塞。
- **缺点**：每个用户线程都需要一个内核线程，增加了内核的负担，线程创建和销毁的开销较大。

---

### 3. **Local Scheduling 和 Global Scheduling**

#### **Local Scheduling (局部调度)**

- **定义**：局部调度是指在一个进程的线程之间进行的调度，通常是在 **Many-to-One** 或 **Many-to-Many** 模型中应用的。在这种调度模式下，线程库负责调度用户线程到一个有效的 LWP（Lightweight Process），也就是用户线程映射到内核线程。
- **进程竞争范围（Process-Contention Scope, PCS）**：局部调度发生在 **同一进程的线程之间**，竞争范围仅限于当前进程内的线程。线程库根据优先级调度不同的用户线程到相应的内核线程上执行。在这种模型下，所有的竞争发生在进程的内部，只有同一个进程内的线程会争夺 CPU 资源。
  
  - **例子**：假设一个进程有 5 个用户线程，它们通过线程库映射到一个或多个内核线程上，这些用户线程之间的调度就属于局部调度。调度策略由用户线程库（如 `pthread`）控制，优先级的选择也是由线程库来决定的。

#### **Global Scheduling (全局调度)**

- **定义**：全局调度是指在整个系统范围内的调度，涉及到多个进程和多个内核线程。在 **One-to-One 模型** 中，每个用户线程都有一个对应的内核线程，因此全局调度会发生在所有内核线程之间。操作系统内核直接调度内核线程到物理处理器上执行。
- **系统竞争范围（System-Contention Scope, SCS）**：全局调度发生在 **所有线程之间**，无论它们属于哪个进程。系统调度器决定哪个内核线程（包括内核线程和用户线程映射的内核线程）获得 CPU 资源。竞争范围不限于同一个进程，而是涉及系统中的所有线程。
  
  - **例子**：在 **一对一模型** 中，每个用户线程都有一个对应的内核线程，因此操作系统会对这些内核线程进行全局调度。全局调度决定了哪些内核线程能够运行，调度会考虑整个系统的线程（包括所有进程的线程）。

---

### 4. **比较 Local Scheduling 和 Global Scheduling**

| 特性                      | **Local Scheduling (局部调度)**                          | **Global Scheduling (全局调度)**                       |
|---------------------------|--------------------------------------------------------|-------------------------------------------------------|
| **调度范围**              | 仅限于进程内的线程，竞争发生在同一进程中的线程之间   | 在整个系统范围内，竞争发生在系统中所有的线程之间   |
| **竞争粒度**              | 进程竞争范围（Process-Contention Scope, PCS）          | 系统竞争范围（System-Contention Scope, SCS）         |
| **使用的模型**            | 多对一或多对多模型                                        | 一对一模型                                            |
| **调度者**                | 线程库负责调度用户线程到 LWP（内核线程）                | 操作系统内核调度内核线程到物理处理器上                |
| **调度策略**              | 线程库根据优先级调度用户线程                            | 操作系统调度器根据内核线程的优先级调度 CPU 资源      |
| **优点**                  | 调度开销较低，进程内线程竞争较简单                      | 系统级调度，能够更好地利用多核处理器，实现并行性     |
| **缺点**                  | 不能有效利用多核处理器，线程间竞争局限于同一进程      | 调度开销较大，每个用户线程都需要映射到一个内核线程    |

---

### 总结：
- **Local Scheduling (局部调度)**：发生在同一进程内的线程之间，调度由用户级线程库负责，通常与 **Many-to-One** 或 **Many-to-Many** 模型配合使用。其竞争范围仅限于进程内部。
  
- **Global Scheduling (全局调度)**：发生在整个系统的线程之间，调度由操作系统内核负责，通常与 **One-to-One** 模型配合使用。其竞争范围涉及系统中的所有线程，能够更好地利用多核处理器并实现并行执行。