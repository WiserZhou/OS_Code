根据您提供的补充信息，**静态链接**、**动态链接**和**动态加载**是计算机程序在与外部库（如共享库或动态链接库）交互时的三种不同方式。它们的主要区别在于**链接时机**、**链接方式**、以及**内存管理的方式**。在此基础上，进一步详细解释每种方法的特点及其区别。

### 1. **静态链接（Static Linking）**

#### **定义**：
静态链接是指在编译阶段完成所有外部库（如静态库 `.a` 或 `.lib` 文件）的链接操作，所有程序需要的库文件中的代码都被复制到生成的可执行文件中。静态链接生成的可执行文件不依赖于外部库，且在程序运行时，库的代码已经包含在其中。

#### **流程**：
- 编译器在编译时将程序代码和所依赖的静态库合并成一个最终的可执行文件，程序在执行时不需要访问外部库。
- 当程序运行时，操作系统直接加载并执行这个独立的可执行文件，不需要再动态加载任何库文件。

#### **特点**：
- **编译时链接**：链接操作发生在程序编译阶段。所有依赖的库文件在编译时被合并到可执行文件中。
- **可执行文件较大**：由于所有的库代码都被拷贝到可执行文件中，生成的可执行文件通常比动态链接的文件要大。
- **没有运行时依赖**：程序运行时不再需要外部库支持，生成的可执行文件独立于系统上的库文件，可以直接运行。
- **更新不方便**：如果某个库发生更新（例如修复了一个 bug 或者改进了性能），则需要重新编译整个程序，否则程序依然会使用旧的库版本。

#### **示例**：
```bash
gcc -o myprogram myprogram.c -lm  # 使用静态链接将数学库链接到程序中
```
- `-lm` 是链接 `libm.a`（静态数学库）到程序中的标志，生成的 `myprogram` 文件会将库代码包含在内。

---

### 2. **动态链接（Dynamic Linking）**

#### **定义**：
动态链接是在程序运行时将外部库（通常是共享库或动态链接库，如 `.dll`、`.so`）与程序进行链接。程序的可执行文件本身并不包含库的代码，而是在运行时由操作系统动态加载并链接所需的库。

#### **流程**：
- 在程序执行过程中，操作系统通过 **动态链接器**（如 `ld.so`）查找并加载所需的共享库（例如 `libm.so`），然后将其链接到程序中。
- 如果库文件不存在或者版本不匹配，程序可能无法启动。

#### **特点**：
- **运行时链接**：动态链接的实际链接操作在程序运行时进行，程序加载时需要操作系统帮助查找和加载动态库。
- **可执行文件较小**：由于可执行文件不包含库的代码，生成的可执行文件通常较小。
- **库更新方便**：只需要更新外部库文件，无需重新编译程序。更新后的库会立即被应用，前提是程序能找到最新版本的库。
- **运行时依赖**：程序依赖外部库，如果程序运行时没有找到必要的库文件，或者库的版本不匹配，程序可能会崩溃或无法启动。

#### **示例**：
```bash
gcc -o myprogram myprogram.c -lm  # 使用动态链接库链接数学库
```
- `libm.so` 或 `libm.dll` 是动态库，程序运行时由操作系统加载。

#### **补充说明**：
- 在动态链接中，程序通常会使用一个 **存根（stub）**，这是一个特殊的代理程序，用来帮助程序在运行时找到正确的库函数。存根会在程序启动时检查所需的库是否已经加载，如果库不在内存中，它会负责加载该库。

---

### 3. **动态加载（Dynamic Loading）**

#### **定义**：
动态加载是一种更灵活的运行时库加载方式，程序在运行时显式地加载所需的库并调用库中的函数。与动态链接不同，动态加载是由程序控制的，程序员可以在需要时动态地加载库，而不是由操作系统自动加载。

#### **流程**：
- 程序在运行时通过显式调用操作系统提供的 API（如 `dlopen()`、`LoadLibrary()`）来加载共享库（`.so`、`.dll`），然后使用 `dlsym()` 或 `GetProcAddress()` 获取库中的函数指针。
- 这种方式通常用于插件架构或按需加载功能，程序可以根据需要加载某些特定的功能，而无需一开始就加载所有库。

#### **特点**：
- **显式加载**：程序必须显式调用函数来加载库文件。例如，在 Linux 中，`dlopen()` 用于加载共享库，`dlsym()` 用于获取函数地址。
- **按需加载**：程序可以在运行时根据实际需求加载和卸载库。加载过程不会在程序启动时完成，而是根据程序的逻辑来决定何时加载。
- **灵活性高**：程序可以在运行时动态加载插件或者替换已有的库，以支持新的功能或版本的更新。
- **性能开销**：每次动态加载都需要通过系统调用，可能会产生额外的开销，尤其是在频繁加载和卸载库时。

#### **示例**：
```c
#include <dlfcn.h>
#include <stdio.h>

int main() {
    void *handle = dlopen("libm.so", RTLD_LAZY);  // 动态加载 libm.so
    if (!handle) {
        fprintf(stderr, "Error: %s\n", dlerror());
        return 1;
    }

    // 获取函数指针
    double (*cos_func)(double) = dlsym(handle, "cos");
    if (!cos_func) {
        fprintf(stderr, "Error: %s\n", dlerror());
        dlclose(handle);
        return 1;
    }

    // 使用库函数
    printf("cos(1) = %f\n", cos_func(1.0));

    // 关闭库
    dlclose(handle);
    return 0;
}
```
- 该示例演示了如何在程序运行时通过 `dlopen()` 加载共享库 `libm.so`，并通过 `dlsym()` 获取 `cos` 函数的指针来执行计算。

---

### 4. **它们之间的区别**：

| 特性               | **静态链接**                                   | **动态链接**                                   | **动态加载**                                   |
|--------------------|-----------------------------------------------|-----------------------------------------------|-----------------------------------------------|
| **链接时机**       | 编译时链接                                    | 运行时链接                                    | 运行时显式加载（程序决定何时加载）              |
| **程序大小**       | 可执行文件较大，因为包含了所有库代码            | 可执行文件较小，因为库文件不包含在程序中         | 可执行文件较小，且按需加载库                   |
| **依赖管理**       | 不依赖外部库，程序完全独立于外部库              | 依赖外部共享库，运行时需要库文件                  | 依赖外部库，但可以在运行时动态决定何时加载库     |
| **库更新**         | 更新库需要重新编译整个程序                      | 更新库时无需重新编译程序，只需要替换库文件       | 更新库时只需替换库文件，程序无需重新编译        |
| **性能**           | 启动速度较快，执行时无额外开销                  | 启动较慢，因需要加载动态库                      | 根据需要加载库的次数，可能会引入加载开销        |
| **灵活性**         | 缺乏灵活性，不能按需加载                        | 程序可自动加载库，支持按需加载                    | 支持动态插件系统，能够按需加载和卸载功能         |

### 总结：
- **静态链接**：程序完全独立于外部库，适合库不频繁更新的场景，但不具备灵活性，且更新不方便。
- **动态链接**：依赖外部库文件，支持运行时库的更新，适用于经常更新的系统库，但在启动时可能较慢。
- **动态加载**：提供最大灵活性，支持按需加载和卸载库，适用于插件系统和需要动态扩展的应用，但可能带来性能开销。