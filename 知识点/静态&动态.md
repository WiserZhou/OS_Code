静态链接、动态链接和动态加载是计算机程序在运行时与外部库（如共享库或动态链接库）的关系及其管理方式的不同方式。它们之间的主要区别在于链接的时机、链接的方式以及内存管理的差异。

### 1. **静态链接（Static Linking）**

#### 定义：
- 静态链接是在编译阶段完成的，所有程序需要的库文件（如函数、变量等）都被复制到程序的可执行文件中。
- 也就是说，编译器在生成可执行文件时，把所有依赖的外部库（静态库）中的代码和资源拷贝到最终的执行文件中，生成的可执行文件独立于其他库文件。

#### 特点：
- **编译时链接**：静态链接在编译时完成，所有依赖的库被合并到最终的可执行文件中。
- **可执行文件较大**：由于所有依赖的代码都被包含在可执行文件中，生成的可执行文件通常较大。
- **没有运行时依赖**：可执行文件不需要外部库支持，可以独立运行。
- **更新不方便**：如果某个库发生了变化（比如修复了 bug 或进行了性能优化），需要重新编译所有依赖该库的程序。

#### 示例：
```bash
gcc -o myprogram myprogram.c -lm  # 将数学库静态链接到程序中
```

### 2. **动态链接（Dynamic Linking）**

#### 定义：
- 动态链接是在程序运行时将外部库（动态链接库）与程序进行连接。程序的可执行文件不会包含库的代码，而是依赖外部库文件（如 `.dll`、`.so` 等）来提供运行时所需的功能。
- 动态链接通常是指 **共享库** 或 **动态链接库**，这些库文件在程序运行时加载到内存中。

#### 特点：
- **运行时链接**：动态链接在程序执行时完成，操作系统会加载相应的动态库并将其链接到正在运行的程序中。
- **可执行文件较小**：由于不包含库代码，生成的可执行文件相对较小。
- **库更新方便**：如果库的功能发生变化，可以直接替换共享库，而不需要重新编译依赖该库的程序。
- **运行时依赖**：程序依赖外部的共享库，若缺少库或库版本不匹配，程序可能无法启动。

#### 示例：
```bash
gcc -o myprogram myprogram.c -lm  # 使用动态链接链接数学库
```
- 这里，`libm.so` 或 `libm.dll` 是一个动态链接库，它在程序运行时由操作系统加载。

### 3. **动态加载（Dynamic Loading）**

#### 定义：
- **动态加载** 是指程序在运行时根据需要 **显式地加载** 和 **链接** 外部库。与动态链接的自动加载不同，动态加载通常需要程序通过调用操作系统提供的 API（如 `dlopen()`、`LoadLibrary()`）来显式加载共享库，并通过 `dlsym()` 或 `GetProcAddress()` 获取库中的函数指针。
- 动态加载允许程序在运行时按需加载某些功能，通常用于插件系统或实现延迟加载。

#### 特点：
- **运行时显式加载**：程序通过系统调用显式地加载库，并在运行时决定是否使用库中的某些功能。
- **按需加载**：程序不需要一开始就加载所有外部库，可以根据实际需要加载库，从而节省内存和提高启动速度。
- **灵活性高**：支持插件架构、动态扩展等功能，可以在运行时加载新的功能或替换已有功能。
- **加载开销**：加载库的过程中会有一定的开销，尤其是需要频繁加载和卸载库时。

#### 示例（Linux）：
```c
#include <dlfcn.h>
#include <stdio.h>

int main() {
    void *handle = dlopen("libm.so", RTLD_LAZY);
    if (!handle) {
        fprintf(stderr, "Error: %s\n", dlerror());
        return 1;
    }
    
    double (*cos_func)(double) = dlsym(handle, "cos");
    if (!cos_func) {
        fprintf(stderr, "Error: %s\n", dlerror());
        dlclose(handle);
        return 1;
    }

    printf("cos(1) = %f\n", cos_func(1.0));
    dlclose(handle);
    return 0;
}
```
- 该程序在运行时通过 `dlopen` 加载 `libm.so`，然后通过 `dlsym` 获取库中的 `cos` 函数。

### 4. **它们之间的区别**

| 特性               | **静态链接**                                      | **动态链接**                                      | **动态加载**                                      |
|--------------------|--------------------------------------------------|--------------------------------------------------|--------------------------------------------------|
| **链接时机**       | 编译时链接                                       | 运行时链接                                       | 运行时显式加载                                    |
| **程序大小**       | 可执行文件较大，因为包含了所有的库代码           | 可执行文件较小，只有符号链接                     | 可执行文件较小，只有加载库的代码                 |
| **依赖管理**       | 不依赖外部库，程序完全独立于外部库               | 依赖外部共享库，程序运行时需要库文件             | 依赖外部库，但可以动态决定何时加载库             |
| **库更新**         | 更新库需要重新编译整个程序                       | 更新库时无需重新编译程序，只需要替换库文件       | 更新库时只需替换库文件，不需要重新编译程序       |
| **性能**           | 启动速度快，性能较好（无需运行时加载）           | 启动速度较慢，因需要加载外部库                   | 根据库的加载和卸载时机，性能可能受到影响         |
| **灵活性**         | 缺乏灵活性，不能按需加载                         | 支持按需加载库，但库的加载是自动的               | 支持高度灵活的按需加载，适合动态插件系统等场景   |

### 总结：
- **静态链接**：编译时将库代码合并到可执行文件中，生成的程序独立于库，适用于不频繁更新的库或资源受限的环境。
- **动态链接**：运行时加载外部库，减少了可执行文件的大小并且支持库的更新，适用于库频繁更新的场景。
- **动态加载**：允许程序在运行时显式加载并使用库，提供了最大的灵活性，适用于插件系统和需要按需加载功能的场景。